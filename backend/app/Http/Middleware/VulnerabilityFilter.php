<?php

namespace App\Http\Middleware;

use Closure;
use Exception;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

class VulnerabilityFilter
{
    protected array $sqlite_keywords = ["%20and%20",
        "%20or%20",
        "%20not%20",
        "%20union%20",
        "%20benchmark%20",
        "%20sleep%20"
    ];
    protected array $escape_strings = [
        "PUT" => "--",
        "POST" => "--",
        "DELETE" => "--",
        "GET" => "--"
    ];
    protected array $image_beginnings = [
        "data:image/jpeg",
        "data:image/png",
        "data:image/gif"
    ];
    protected array $magic_bytes = [
        "47494638", //GIF
        "ffd8ffe0", //JPEG
        "89504e47", //PNG
    ];

    /**
     * Handle an incoming request.
     *
     * @param \Illuminate\Http\Request $request
     * @param \Closure(\Illuminate\Http\Request): (\Illuminate\Http\Response|\Illuminate\Http\RedirectResponse)  $next
     * @return \Illuminate\Http\Response|\Illuminate\Http\RedirectResponse
     */
    public function handle(Request $request, Closure $next)
    {
        $verb = $request->method();
        $uri = $request->getRequestUri();
        $body_content = $request->getContent();
        $uri_without_params = $this->getUriWithoutParams($uri);

        $sqli_difficulty = $this->getDifficulty($uri_without_params, "sqli_difficulty");
        $rxss_difficulty = $this->getDifficulty($uri_without_params, "rxss_difficulty");
        $sxss_difficulty = $this->getDifficulty($uri_without_params, "sxss_difficulty");
        $cmdi_difficulty = $this->getDifficulty($uri_without_params, "cmdi_difficulty");

        $body_content = $this->filter($sqli_difficulty, $body_content, $sxss_difficulty, $cmdi_difficulty, $verb);
        $uri = $this->filterUri($uri, $sqli_difficulty, $rxss_difficulty, $cmdi_difficulty, $verb);

        $final_request = $this->createFinalRequest($uri, $request, $body_content);

        $response = $next($final_request);
        return $response->header("Access-Control-Expose-Headers", "VulnFound, self")->header("self", $uri);
    }

    /**
     * Format $uri the way URIs are stored in the database
     * i.e. remove query params, replace numbers with {int}
     *
     * @param string $uri
     * @return array|string|string[]|null
     */
    public function getUriWithoutParams(string $uri): string|array|null
    {
        $uri_without_params = explode("?", $uri)[0];
        $uri_without_params = preg_replace("/\/\d+\//", "/{int}/", $uri_without_params);
        return preg_replace("/\/\d+(.)*/", "/{int}", $uri_without_params);
    }

    /**
     * get difficulty from DB
     *
     * @param $uri
     * @param $type
     * @return int
     */
    public function getDifficulty($uri, $type): int
    {
        try {
            $difficulty = $this->readDifficultyFromDB($uri, $type);
            return (int)$difficulty;
        } catch (Exception) {
            return 4;
        }
    }

    /**
     * actual query for getting difficulty from DB
     *
     * @param $uri
     * @param $type
     * @return int|mixed|null
     */
    public function readDifficultyFromDB($uri, $type): mixed
    {
        $difficulty = DB::connection('secure')
            ->table('vulnerabilities')
            ->where('uri', "=",$uri)
            ->value($type);
        if ($difficulty == null) {
            $difficulty = 4;
        }
        return $difficulty;
    }

    /**
     * perform actual filtering
     * aborts with code 418 if command injection is detected
     *
     * @param mixed $sqli_difficulty
     * @param array|string $uri
     * @param mixed $xss_difficulty
     * @param mixed $cmdi_difficulty
     * @param string $verb
     * @return string|array
     */
    public function filter(mixed $sqli_difficulty, array|string $uri, mixed $xss_difficulty, mixed $cmdi_difficulty, string $verb): string|array
    {
        $uri = $this->filterSqliEscape($sqli_difficulty, $uri, $verb);
        if($this->filterCommandInjection($cmdi_difficulty, $uri)) {
            abort(418);
        }
        return $this->filterXss($xss_difficulty, $uri);
    }

    /**
     * filter SQL injection by removing the escape string
     *
     * @param mixed $sqli_difficulty
     * @param array|string $uri
     * @param string $verb
     * @return string|array
     */
    public function filterSqliEscape(mixed $sqli_difficulty, array|string $uri, string $verb): string|array
    {
        if ($sqli_difficulty > 1) {
            while (strpos($uri, $this->escape_strings[$verb])!= false) {
                $uri = str_ireplace($this->escape_strings[$verb], "", $uri);
                if ($sqli_difficulty == 2) {
                    break;
                }
            }
        }
        return $uri;
    }

    /**
     * detect command injection via file type or magic bytes, depending on difficulty
     *
     * @param mixed $cmdi_difficulty
     * @param array|string $uri
     * @return bool
     */
    public function filterCommandInjection(mixed $cmdi_difficulty, array|string $uri): bool
    {
        //two null checks necessary here - one to check whether the string even exists, one to check whether it was a proper JSON string
        if($uri == null) {
            return false;
        }
        $isImage = true;
        $uri = json_decode($uri, true);
        if($uri == null) {
            return false;
        }
        if(array_key_exists('profilePicture', $uri)) {
            $image = $uri['profilePicture'];
            if($cmdi_difficulty > 1) {
                $isImage = $this->validateFileType($image);
            }
            if($cmdi_difficulty > 2 && $isImage) {
                $isImage = $this->validateMagicBytes($image);
            }
        }
        return !$isImage;
    }

    /**
     * check a base64 encoded image's file type
     *
     * @param mixed $image
     * @return bool
     */
    public function validateFileType(mixed $image): bool
    {
        $isImage = false;
        foreach ($this->image_beginnings as $beginning) {
            if (str_starts_with($image, $beginning)) {
                $isImage = true;
                break;
            }
        }
        return $isImage;
    }

    /**
     * check a base64 encoded image's magic bytes
     * return false if magic bytes aren't those of JPEG, GIF or PNG, true if they are
     *
     * @param mixed $image
     * @return bool
     */
    public function validateMagicBytes(mixed $image): bool
    {
        $image = $this->leftTrim($image, 'data:image/jpeg;base64,');
        $image = $this->leftTrim($image, 'data:image/gif;base64,');
        $image = $this->leftTrim($image, 'data:image/png;base64,');

        $image = bin2hex(base64_decode($image));
        $isImage = false;
        foreach ($this->magic_bytes as $magic_byte) {
            if (str_starts_with($image, $magic_byte)) {
                $isImage = true;
                break;
            }
        }
        return $isImage;
    }

    /**
     * remove $prefix from the beginning of $text, if $text starts with $prefix
     * @param $text
     * @param $prefix
     * @return string
     */
    function leftTrim($text, $prefix): string
    {
        if(str_starts_with($text, $prefix)) {
            $text = substr($text, strlen($prefix));
        }
        return $text;
    }

    /**
     * filter cross-site-scripting by removing either the script tags or all <>, depending on difficulty
     *
     * @param mixed $xss_difficulty
     * @param array|string $uri
     * @return array|string|string[]
     */
    public function filterXss(mixed $xss_difficulty, array|string $uri): string|array
    {
        if ($xss_difficulty > 3) {
            $uri = str_ireplace("<", "", $uri);
            $uri = str_ireplace(">", "", $uri);
            $uri = str_ireplace("%3C", "", $uri);
            $uri = str_ireplace("%3E", "", $uri);
        } else if ($xss_difficulty > 1) {
            while (preg_match("/<\/?script>/", $uri) != false) {
                $uri = str_ireplace("<script>", "", $uri);
                $uri = str_ireplace("</script>", "", $uri);
                if ($xss_difficulty == 2) {
                    break;
                }
            }
            while (preg_match("/%3C\/?script%3E/", $uri) != false) {
                $uri = str_ireplace("%3Cscript%3E", "", $uri);
                $uri = str_ireplace("%3C/script%3E", "", $uri);
                if ($xss_difficulty == 2) {
                    break;
                }
            }
        }
        return $uri;
    }

    /**
     * filters URI for SQLI, reflected XSS
     *
     * @param string $uri
     * @param int $sqli_difficulty
     * @param int $rxss_difficulty
     * @param int $cmdi_difficulty
     * @param string $verb
     * @return string|array
     */
    public function filterUri(string $uri, int $sqli_difficulty, int $rxss_difficulty, int $cmdi_difficulty, string $verb): string|array
    {
        $uri_segments = explode("?", $uri);
        $uri_segments[0] = $this->filterSqliteKeywords($uri_segments[0], $sqli_difficulty);
        if (count($uri_segments) >= 2) {
            $uri = $this->filterQueryParams($sqli_difficulty, $uri_segments, $rxss_difficulty, $cmdi_difficulty, $verb);
        } else {
            $uri = $uri_segments[0];
        }
        return $uri;
    }

    /**
     * filters SQLite keywords from $uri
     *
     * @param string $uri
     * @param int $sqli_difficulty
     * @return string|array
     */
    public function filterSqliteKeywords(string $uri, int $sqli_difficulty): string|array
    {
        if ($sqli_difficulty > 2) {
            while ($this->checkSqliteKeywords($uri)) {
                foreach ($this->sqlite_keywords as $keyword) {
                    $uri = str_ireplace($keyword, "", $uri);
                }
                if ($sqli_difficulty == 3) {
                    break;
                }
            }
        }
        return $uri;
    }

    /**
     * check whether $uri contains SQLite keywords
     *
     * @param string $uri
     * @return bool
     */
    public function checkSqliteKeywords(string $uri): bool
    {
        return (new VulnerabilityMonitor())->checkKeywords($uri, $this->sqlite_keywords);
    }

    /**
     * filter query params for SQLI and RXSS. Command Injection difficulty needs to be provided, but won't be used.
     *
     * @param int $sqli_difficulty
     * @param array $uri_segments
     * @param int $rxss_difficulty
     * @param int $cmdi_difficulty
     * @param string $verb
     * @return string
     */
    public function filterQueryParams(int $sqli_difficulty, array $uri_segments, int $rxss_difficulty, int $cmdi_difficulty, string $verb): string
    {
        $uri_segments[1] = $this->filter($sqli_difficulty, $uri_segments[1], $rxss_difficulty, $cmdi_difficulty, $verb);
        return $uri_segments[0] . "?" . $uri_segments[1];
    }

    /**
     * generate the final request passed onto the other middleware and controllers after filtering the content
     *
     * @param array|string $uri
     * @param Request $request
     * @param array|string $body_content
     * @return Request
     */
    public function createFinalRequest(array|string $uri, Request $request, array|string $body_content): Request
    {
        $uri = ltrim($uri, '/');
        $uri_without_params = explode("?", $uri)[0];
        $params = $this->getParamsFromUri($uri);
        return Request::create($uri_without_params, $request->method(), $params, $request->cookies->all(), $request->allFiles(), $request->server->all(), $body_content);
    }

    /**
     * extract query params from $uri
     *
     * @param string $uri
     * @return array|string|string[]|null
     */
    public function getParamsFromUri(string $uri): string|array|null
    {
        $uri_segments = explode("?", $uri);
        if(sizeof($uri_segments) > 1) {
            return $this->parseParams($uri_segments[1]);
        }
        return array();
    }

    /**
     * parse query params passed as string into array
     *
     * @param $uri_segments
     * @return array
     */
    public function parseParams($uri_segments): array
    {
        $uri = $uri_segments;
        $params = explode("&", $uri);
        $result = array();
        foreach ($params as $param) {
            $parts = explode("=", $param);
            $val = str_ireplace("%3C", "<", $parts[1]);
            $val = str_ireplace("%3E", ">", $val);
            $result[$parts[0]] = $val;
        }
        return $result;
    }
}
